import json
import socket
import threading
import os
from dotenv import load_dotenv
from gui_server import ServerGUI
import tkinter as tk
from logger import log_connection_event, log_transaction_event
# Cryptography dependencies
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding, hashes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from hashlib import pbkdf2_hmac
import secrets

# use the db_lock to read/write to/from users.json file to allow for synchronization
USER_FILE = "users.json"
db_lock = threading.lock()

server_nonces = []
server_nonces_lock = threading.Lock()
nonce_ceiling = 10000000

def load_users():
    if os.path.exists(USER_FILE):
        with open(USER_FILE, "r") as f:
            return json.load(f)
    return {}

def save_users(users):
    print("[DEBUG] Saving users to file...")
    with open(USER_FILE, "w") as f:
        json.dump(users, f)
    print("[DEBUG] Save complete.")

# API to generate shared symmetric key for an ATM and the server, the one we assume
# both "already have", referred to as K_s in sys design diagram
def generate_server_ATM_shared_key(atm_number: int):
    shared_secret = os.getenv("ATM_SERVER_SHARED_SECRET")
    shared_secret_bytes = shared_secret.encode()
    salt_str = os.getenv(f"ATM_{atm_number}_SALT")
    salt_bytes = salt_str.encode()
    # derive key
    kdf = pbkdf2_hmac(
        algorithms = hashes.SHA256(),
        length = 32,
        salt = salt_bytes,
        iterations = 10000,
    )

    return kdf.derive(shared_secret_bytes)
    
def generate_nonce():
    # thread safe lock
    with server_nonces_lock:
        rand_int = secrets.randbelow(nonce_ceiling)
        # generate nonce repetitively until we get a unique value not in our server nonces
        while(True):
            if rand_int not in server_nonces:
                break
            rand_int = secrets.randbelow(nonce_ceiling)
        server_nonces.append(rand_int)
        return rand_int

""" 
this method will output a 256 bit AES key (our encryption key) and a 256 bit MAC key

"""
def generate_enc_and_MAC_key(master_secret: bytes, pre_master_secret: bytes):
    iter = 10000
    # use the first 16 bytes of pre master secret as salt for our keys to ensure they are symmetric
    pre_master_salt = pre_master_secret[:16]
    aes_kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,  
        salt=pre_master_salt,
        iterations=iter
    )

    MAC_kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,  # 32 bytes for HMAC-SHA256
        salt=pre_master_salt,
        iterations=iter
    )

    AES_encryption_key = aes_kdf.derive(master_secret)
    MAC_key = MAC_kdf.derive(master_secret)
    return AES_encryption_key, MAC_key


# NOTE FOR BELOW 2 FUNCTIONS:
# IV must be 16 bytes

# decrypt data encrypted with shared key (K_s)
def decrypt_with_K_s(encr_data: bytes, key: bytes, IV: bytes):
    cipher = Cipher(algorithms.AES(key), modes.CBC(IV), backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted_data = decryptor.update(encr_data) + decryptor.finalize()
    unpadder = padding.PKCS7(128).unpadder() 
    unpadded_data = unpadder.update(decrypted_data) + unpadder.finalize()
    return unpadded_data.decode('utf-8')

# encrypt data with shared key (K_s)
def encrypt_with_K_s(data: bytes, key: bytes, IV: bytes):
    data_bytes= data.encode('utf-8')
    padder = padding.PKCS7(128).padder()  # AES block size is 128 bits (16 bytes)
    padded_data = padder.update(data_bytes) + padder.finalize()
    cipher = Cipher(algorithms.AES(key), modes.CBC(IV), backend=default_backend())
    encryptor = cipher.encryptor()
    encr_data = encryptor.update(padded_data) + encryptor.finalize()
    return encr_data



# customer sends N_atm (nonce generated by ATM), we decrypt it and send unencrypted value back in next message
""" args: 
customer_nonce_encrypted: The encrypted nonce value the ATM generated and sent to server
symmetric_AES_key: K_s 
ATM_IV: initialization vector (should be generated by ATM) used to decrypt nonce
"""
def authenticate_customer(customer_nonce_encrypted: bytes, symmetric_AES_key: bytes, ATM_IV: bytes):
    print()

# authentication protocol that generates the shared encryption key and MAC key
def authentication_protocol():
    print("temp")


USER_DATABASE = load_users()

HOST = 'localhost'
PORT = 8888

# prerequisites to handling a client:
# generate shared symmetric AES key
def handle_client(conn: socket.socket, addr, connection_log: list, transaction_log: list):
    print(f"[+] Connection from {addr}")
    authenticated = False
    try:
        while True:
            data = conn.recv(1024).decode()
            if not data:
                break
            message = json.loads(data)
            print(f"message:{message}")
            if message["type"] == "login":
                username = message["username"].strip()
                password = message["username"].strip()
                print(f"[>] Login attempt: {username}")
                if USER_DATABASE.get(username) == password:
                    conn.sendall("SUCCESS".encode())
                    log_connection_event(connection_log, username, "login", addr[1])
                else:
                    conn.sendall("FAIL".encode())
            elif message["type"] == "signup":
                print("signup")
            elif message["type"] == "auth-series":
                print("authentication")
            
            # if data.startswith("LOGIN:"):
            #     _, username, password = data.split(":", 2)
            #     username = username.strip()
            #     password = password.strip()
            #     print(f"[>] Login attempt: {username}")

                if USER_DATABASE.get(username) == password:
                    conn.sendall("SUCCESS".encode())
                    log_connection_event(connection_log, username, "login", addr[1])
                else:
                    conn.sendall("FAIL".encode())
            # elif data.startswith("REGISTER:"):
            #     _, username, password = data.split(":", 2)
            #     username = username.strip()
            #     password = password.strip()
            #     print(f"[>] Register attempt: {username}")
            #     if username in USER_DATABASE:
            #         conn.sendall("FAIL".encode())
            #     else:
            #         USER_DATABASE[username] = password
            #         save_users(USER_DATABASE)
            #         conn.sendall("SUCCESS".encode())
            #         log_connection_event(connection_log, username, "register", addr[1])
            # else:
            #     conn.sendall("UNKNOWN_COMMAND".encode())
    except Exception as e:
        print(f"[!] Error handling client {addr}: {e}")
    finally:
        conn.close()
        print(f"[-] Disconnected: {addr}")

if __name__ == "__main__":
    connection_log = []
    transaction_log = []
    load_dotenv()

    def start_server():
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
            server_socket.bind((HOST, PORT))
            server_socket.listen()
            print(f"[+] Server listening on {HOST}:{PORT}")

            while True:
                conn, addr = server_socket.accept()
                thread = threading.Thread(target=handle_client, args=(conn, addr, connection_log, transaction_log))
                thread.start()

    # Start server thread
    threading.Thread(target=start_server, daemon=True).start()

    # Start GUI
    root = tk.Tk()
    gui = ServerGUI(root, connection_log, transaction_log)
    root.mainloop()


